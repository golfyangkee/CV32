<< 아날로그  -> 디지털화  >>
아날로그  -> [ 샘플링  -> 양자화  -> 이진화 ]   -> 디지털화 (샘플링양자화이진화그림설명.png 보기)
   - 샘플링 : 연속적인 아날로그 신호를 일정한 시간 간격으로 샘플링 하는 작업 후 이산화 작업
   - 양자화 : 샘플링된 값들을 특정한 정밀도와 범위(구간)를 가진 숫자값들로 변환 (연속적인 아날로그 값을 디지털로 근사화 시킨다)
   - 이진화 : 양자화된 값을 이진코드로 변환해서 디지털 값으로 리턴 (최대, 최소, 중간값 등)

<<  디지털화 ->  아날로그   >>
복호화  :  디지털 데이터를 이진화  -> 양자화  ->  신호복원

1. 이미지 양자화   : 연속적인 이미지 픽셀 값을 유한한 범위의 이산 값으로 매핑하는 과정을 의미
 - 목적 :  표현 가능한 픽셀 값의 수를 줄여 저장 공간이나 전송 대역폭을 절약하기 위한 방법이다.
 - 균일과 비균일로 이루어진다.

     [균일 양자화]: 모든 픽셀 값의 범위를 동일한 간격으로 나눈다.
     ex) 0~255 사이의 그레이스케일 값 ->  0, 51, 102, ..., 255과 같은 값으로 매핑
         quantized_image = (image / 51) * 51

     [비균일 양자화]: 이미지의 통계적 또는 심리 시각적 특성을 고려하여 픽셀 값의 범위를 나눈다.
       ex) K-means 양자화
       quantized_pixels = kmeans.cluster_centers_[kmeans.labels_].reshape(image.shape)
       quantized_image = np.array(quantized_pixels, dtype=np.uint8)

 - JPEG 압축에서의 양자화는 Discrete Cosine Transform (DCT)를 통해 얻은 계수를 일정한 값으로 나누는 과정을 포함한다.

      cv2.imwrite("compressed_image.jpg", image, [cv2.IMWRITE_JPEG_QUALITY, 10])

      양자화의 정도는 JPEG 품질 설정에 따라 다르며 품질이 높으면 양자화는 덜 심하고, 품질이 낮으면 양자화는 더 심해진다.
       DCT _ 데이터압축 : 소리, 이미지를 주파수 도메인 으로 변환 후 데이터의 주요 주파수 성분을 사용할 수 있도록 촛점을 맞춘다.
       아날로그 주파수분리 : FT
================================================================================================
 * 양자화를 하는 이유 ?
   ===> 이미지나 신호에서 정보를 유지하면서 크기를 줄이는데 사용된다. (원본 유지)
 * 양자화 종류 ((+) 의미 : 오픈CV에서 제공X, 추가해야한다.)
    - K-means 양자화: 이미지의 각 픽셀 값을 k개의 중심 값 중 하나로 매핑 양자화(컬러 양자화)
    - Vector Quantization (VQ): K-means의 일반화된 형태로, 여러 차원의 데이터 포인트를 양자화(+)

   -  영역 기반 양자화 (Region-based Quantization): 이미지를 여러 영역으로 나눈 후, 각 영역 내에서 양자화를 적용
         ex)cv2.split()
   -  데이터베이스 양자화: 이미지의 픽셀 값을 미리 정의된 몇 가지 값 중 하나로 대체하는 방법 LUT(Look-Up Table)를 사용
        ex)cv2.LUT()
            핸드폰에서 많이 쓰는데 밤에 사진 찍고 어두워서 밝기 조정 시 안 보이던거 보이게 한다.
            잘 안 보이는데 밝기 조정으로 필터링 하면 나오는데 이렇게 해도 잘 안 보이면 데이터베이스 양자화한다.
            밝기 조절 딥하게 할 때 사용
   -  차등 양자화 (Differential Quantization): 픽셀 값 대신 픽셀 값의 차이를 양자화
        ex) numpy.diff() ,  numpy.cumsum()
            데이터가 있는데 밝기를 해도 안 나와 돌려도 안 나와 이러면
            반디집, 캄타시아 이런 유료틀에서 사용할 때 차등 양자화 많이 쓴다. 금액이 다르다.
            diff()는 3.4버전부터는 openCV에도 있긴하다.(우리는 4.9)

   -  Scalable Quantization: 다양한 해상도에  동작이 잘 되도록 설계된 양자화(+)

   -  Binarization: 픽셀 값을 두 가지 값 중 하나 만들어 이미지를 단순화하여 계산을 빠르게 하거나, 특정 정보를 추출할 때 사용
        ex)cv2.threshold() 또는 cv2.adaptiveThreshold()
        이진화로 만들어서 임계값 지정,

   - Simple Quantization :값을 일정 범위로 나눈 후 해당 범위의 평균 값이나 중앙 값으로 대체 (+)

 * 주의: 양자화는 이미지의 각 픽셀 값이 가질 수 있는 수치 범위를 줄이는 과정이므로 [shape는 영향을 미치지 않는다]
 ** 자율주행에서는 scalable, vector 많이 쓰고, 드론은 simple quantization 많이 씀, 이 3개는 평이한 애들이 아니다.
 ===================================================================================================

2. 색상공간 변경
c_color_space.py  : cvtColor 함수를 사용하면 이미지의 색상 공간을 다양하게 변경할 수 있다.
BGR to Gray: 컬러 이미지를 흑백 이미지로 변환
BGR to HSV: BGR 색상 공간에서 HSV 색상 공간으로 변환
BGR to YCrCb: BGR 색상 공간에서 YCrCb 색상 공간으로 변환

  - HSV는 "Hue, Saturation, Value"의 약자로, 색상(Hue), 채도(Saturation), 밝기(Value)를 나타내는 색공간 색표현 모델
  -  BT.601   = RGB에서 Y 값을 산출하는 공식  = RGB 컬러 이미지를 흑백으로 변환하는 경우, 신호 Y 값을 산출
      #   Y   =  0.299* R    +    0.587 *  G     +  0.114 *  B
  -  BT.601 : 일반적인 사람의 시각 특성을 고려한 것으로 가장 밝게 느껴지는 G(녹색)의 계수가 커지는 것을 확인
    * * 요즘은 노트북은 녹색계수 자동이다.

1번은 양자화 임라이트에 jpg저장할 때 퀄리티
2번은 공간 설정법이 목적에 따라 다르다
그레이로 가져올 때는 정확하게 색상공간을 BT601 보통 이걸로 쓴다.
y계수를 해당 값으로 추출
BT601로 밝게 느껴지게끔 한다.
목적에 따라 4개의 섹션으로 해당 프로세싱 처리 한다. CvtColor - 쉐입 변환 없고 경계선 등 다르다.
d 파일은 Y 계수 명시한거고
e 파일은 자동으로 공식 적용해주는 거고 cv.COLOR_BGR2GRAY
cv.imread는 BT601 구현되지 않는다. 코덱에 따라 화소가 다르다. 동적
color_bgr2gray는 정적연산

3. 이미지 결합ㅉ
이미지 결합 = 세로 연결 / 가로 연결 / 바둑판 연결
cv.vconcat() - 폭이 동일한 이미지를 세로로 연결
            - 같은 이미지를 반복 세로 연결
            - 폭이 서로 다른 이미지도 세로로 연결
  주의점  : 같은  폭   ,  같은 채널 수  , 데이터 타입 일치 , None(오류)
src[i].dims <= 2 && src[i].cols == src[0].cols && src[i].type() == src[0].type()


cv.hconcat() - 높이가 동일한 이미지를 가로로 연결
            - 같은 이미지를 반복 가로 연결
            - 높이가 서로 다른 이미지도 가로 연결
   주의점  : 같은  높이  ,  같은 채널 수  , 데이터 타입 일치 , None(오류)
   src[i].dims <= 2 && src[i].rows == src[0].rows && src[i].type() == src[0].type()


np.tile() : 같은 이미지를 반복 정렬

=============================================================================================
[질문] 자율주행차량의 카메라에 보이는 물체랑 측정하는 카메라 위치와의 거리도 측정이 가능한지 궁금합니다
[답변]  스테레오카메라 (물체거리 측정 )  /ToF(빛 속도로 거리 측정) / LiDAR 시스템 (레이저 빔 )  : 3D map
        모노 카메라  (싱글카메라 렌즈 )
========================================================================================

<< HSV 란? >>
HSV는 색상(Hue), 채도(Saturation), 명도(Value)를 나타내는 색상 모델이며, 이미지 처리 및 컴퓨터 비전에서 널리 사용됩니다.

-색상(Hue):    색상은 색의 질을 나타냅니다.
             색상은 원형으로 표현되며, 0에서 360까지의 각도로 표현됩니다.
             일반적으로 빨강(0도), 녹색(120도), 파랑(240도)을 기준으로 색상이 정의됩니다.

-채도(Saturation): 채도는 색의 강도 또는 순도를 나타냅니다.
                 채도가 높을수록 색이 더 강렬하고 순수해 보입니다.
                 채도는 0에서 100% 사이의 값으로 표현되며, 0%는 회색이고 100%는 순수한 색입니다.

-명도(Value): 명도는 색의 밝기를 나타냅니다.
            명도는 색의 어두운 정도를 결정하며, 값은 0에서 100%까지이며, 0은 검은색이고 100은 백색입니다.

HSV 색상 공간은 RGB(Red, Green, Blue) 색상 공간과는 달리 색상, 채도 및 명도로 분리되어 있어 색의 특성을 더 쉽게 조작하고 분석할 수 있습니다.
예를 들어, HSV 색상 공간에서는 색상을 기준으로 이미지를 분할하거나 특정 색상 범위를 필터링하는 것이 간단해집니다.
HSV 색상 모델은 이미지 처리에서 색상에 기반한 작업을 수행하는 데 유용하게 활용됩니다.

========================================================================================

<< HSV = (색상, 채도, 명도) 로 CV에서 프로세싱하는 목적 >>
1. 색상 = 단일 채널 색상, 특정 색의 객체를 추적하거나 배경에서 분리하는 작업을 할 때 사용
2. 채도, 명도 = 이미지 색상 강도, 밝기 변화
3. 불변성 확보 = 조명 변화는 불변, 야외 환경 또는 다양한 조명 상태의 응용프로그램 (밖에 조명이 여러개 있을 때는 유리, 실내의 간접조명 이럴 때는 불리)
        자동차가 터널 안에 딱 들어가서 조명 하나 키면 BGR로 함
4. 색상 기반 필터링 사용 = 피부색, 특정 배경 감지 분리 (피부과 화장품샵 가면 카메라로 피부색상 읽어서 어울리는 립 색상 보여준다)

CvgColor.jpg 설명
24.02.13 오후 1시 10분
RGB <-> GRAY : OCR, 엣지검출, 탐지시스템
RGB <-> CIE XYZ : 피부과
RGB <-> YCrCB JPEG :

RGB <-> HSV : 야외, 조명 다양
RGB <-> HLS : 이미지 명암 조절할 때 사용

RGB <-> CIE Lab : 3D~5D 객체 추적, 공간 시뮬레이션 할 때 사용
RGB <-> CIE Luv : 3D~5D 객체 추적, 공간 시뮬레이션 할 때 사용

Bayer -> RGB : 디지털 카메라 렌즈 안에 붙어서 나온다.

CIE는 국제 조명 위원회 이름이다.





