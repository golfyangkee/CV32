1. Blur (Blurring or Smoothing)
목적: 노이즈 제거, 이미지를 부드럽게 만들어 다른 이미지 처리 작업을 쉽게 함
    물체의 선명한 특징을 감소시켜 객체 인식에 도움을 줌
특징: 선명도가 줄어듦 ,가우시안 블러, 미디언 블러, bilateralFilter 블러 등 다양한 블러링 방법이 있음

2. Edge Detection (Canny, Sobel)
객체의 경계를 찾음 , 이미지에서 중요한 구조적 정보를 추출, 특징 검출과 매칭에서의 사용
특징: 경계선이 명확해짐(이미지 밝기 변화율에 대해서), 노이즈에 민감할 수 있음 (따라서 블러링을 먼저 적용하는 것이 일반적)

3. Morphology Operations (Erosion, Dilation, etc.)
목적: 노이즈 제거,객체 구조 개선 (구멍 메우기, 갭 연결 등),객체 분리
특징: 구조 요소(Structuring Element)와의 연산을 통해 이미지 형태를 변경
침식(Erosion)과 팽창(Dilation)은 가장 기본적인 모폴로지 연산
모폴로지 연산은 노이즈 제거, 객체 구분, 객체 개선 등 다양한 목적으로 사용됨

===================================================================
===================================================================================================================
240214(수) 오전 9시 20분
안에 있는 픽셀은 그대로 나두고 전체적인 외곽에서 뷰단만 보여줬다면
고수준은 실제 픽셀을 조합해서 변환한다.
그러고 필터링 시킨다.
영상에 읽어드릴ㄹ 대 해상도 포함 4가지 컬러, 그레이크세일, 이진화, 인덱스
이진화 바이너리로 들어와서 인덱스 하면 고수준이랑 맞먹어서
커널 마스크 적용한다음에 실제 이미지가 바뀐다.
4가지 패턴에서 2개는 실제 이미지 건드리지 않고
나머지 2개는 고수준에서 이미지 건드린다.
변환을 시키면 x,y 채널 채널값이나 xy값을 가져다가 변환 작업을 하는데
내부 연산을 하는데
연산 기법이 다양하다.

blur, edge, morpology 단계
개발할 때도 섞어 쓰시는 분들이 계셔서
순서대로 해라 라고 한다.
blur는 소위 필터작업을 해준다.
이미지가 들어오면 저수준 고수준을 프로세싱을 이용해서 흐리게 필터링
edge 는 필터가 되어 있는 상태에서 경계를 만든다. 경계작업
모폴로지는 경계작업을 만들고 놨더니 구멍이 생겨서 구멍 메우는 작업을 한다.
그러고 나서 분석에 들어가면 굉장히 편하다.

사진이 너무 낡으면
첫번 째 필터작업 blur
거기다가 사람의 경계를 만든다. edge
그 다음에 경계면에 구멍이 뚫려 있으면
모폴리지로 구멍 메우고
분류, 박스, 세그멘테이션 하던 한다.
실제 픽셀을 건드려서 연산을 하는데

앞 단에 뭐가 되어 있어야 하냐면
이미지 리사이즈
각도 틀어져 있어 각도 맞추고
여러장이면 분활이야
한장에 객체 2개야 밝기 조정, 그림자가 짙어 대비재도? 이런 필터링을 하고
그 다음에 마스크 필터를 하는거다.

사과 이미지를 가지고 오자 하면
하나 짜리도 있고 여러개 짜리도 있으면 분류작업을 하고
다 사이즈가 달라
그러면 사이즈부터 맞추고
이름을 바꾼다.
다운로드 받을 때 라벨링을 줘서 파일 이름을 바꿔야 하는데
그 다음 톤을 맞춰야 한다. 화소를 맞추고
동일하게 만든다음에 어두운 애는 밝게 등 밝기 조절하고
그 다음
마스크 필터링 진행한다.

분석을 하거나 CV 특징을 하려면
필터 경계 구멍을 잘 해야한다.
앞에 프로세싱도 잘 되어 있어야 한다.

이미지 프로세싱 목표는?
블러 엣지 모폴로지를 하기 위해 앞에 이미지 프로세싱(1~3)을 하는 거다

감마랑 임계값하면
기본이 달라진다.
임계값 이진화
감마는 전체 이미지에서 사용
뒤로 가면 헷갈릴 수 있다.
감마보정은 실제 컬러나 그레이스케일에서 하는 작업이고
임계값은 이진화에서 처리
경계가 정확하게 있어야 한다.
임계값 스테홀딩을 하고 감마랑 이미지 느낌이 비슷하다 보니 혼선이 올 수 있으나
감마는 해상도 처리 - 전체 이미지
임계값은 실제 이미지 처리 - 점기반 연산, 특정 구간만
감마 함수도 있고 아니면 넘파이 메소드로 밝기 조절

마스크와필터 설명
점기반 포함 주변연산을 하는 애들인데
용어가 필터 마스크 커널을 쓴다.
필터는 명확하게 지정된 영역이나 특정부분 강조
마스크 무작위 부분 일부분만
커널은 필터링, 엣지 감지 등에 사용
커널안에 필터랑 마스크 포함
실행 방법은 동일하다
3*3 배열만드어서 콤볼로션 연산 혹은 배열 연산
원형은 똑같고 사용방법도 똑같은데
메이커 측에서 부르는 호칭이 필터 마스크 커널 이렇게 3가지 이다.
연산 따로 얘기 없으면 컨볼루션연산으로 처리한다.

================================================================================================================
240214 수 오후 2시 35분
https://docs.opencv.org/4.9.0/d4/d86/group__imgproc__filter.html

# 바이너리 또는 그레이스케일로 로드 후 연산
★★★★★★★★★★★★★ 암기 ★★★★★★★★★★★★★★★★★★★★★★★★★★★
https://docs.opencv.org/4.9.0/d4/d86/group__imgproc__filter.html#ga7be549266bad7b2e6a04db49827f9f32
모폴로지 매개변수

cv::MorphTypes {
  cv::MORPH_ERODE = 0,    : 이미지 경계 축소 (침식) -> 작은 오브젝트 제거, 오브젝트의 간격을 늘린다.
  cv::MORPH_DILATE = 1,   : 경계 확장 (팽창) -> 침식으로 사라진 오브젝트를 복원하거나 더 크게 만든다.
  cv::MORPH_OPEN = 2,     : 침식 -> 팽창 : 작은 오브젝트 제거 - 배경에 있는 거 지움
  cv::MORPH_CLOSE = 3,    : 팽창 -> 침식 : 내부의 작은 구멍 채우기 - 내부에 있는 거 지움
  cv::MORPH_GRADIENT = 4, : [팽창이미지 - 침식이미지] 결과로 이미지 생성 : 오브젝트 윤곽이 강조
                            dst=morph_grad(src,element)=dilate(src,element)−erode(src,element)
  cv::MORPH_TOPHAT = 5,   : [원본이미지 - MORPH_OPEN] 결과로 이미지 생성 : 밝은 오브젝트가 어두운 배경에 있을 때 사용
                            dst=tophat(src,element)=src−open(src,element)
  cv::MORPH_BLACKHAT = 6, : [MORPH_CLOSE - 원본이미지] 결과로 이미지 생성 : 어두운 오브젝트가 밝은 배경에 있을 때 사용
                            dst=blackhat(src,element)=close(src,element)−src
  cv::MORPH_HITMISS = 7   :
}

Note:
The number of iterations is the number of times erosion or dilatation operation will be applied.
For instance, an opening operation (MORPH_OPEN) with two iterations is equivalent to apply successively
: erode -> erode -> dilate -> dilate (and not erode -> dilate -> erode -> dilate).
=> 해석
반복횟수는 침식이나 팽창에 적용되는 횟수이다.
예를 들어, 모폴로지 연산은 1번 밖에 안 된다.

MORPH_OPEN 순서
열림 연산은 침식 후 팽창
침식 -> 침식 -> 팽창 -> 팽창
erode -> erode -> dilate -> dilate
erode -> 이미지의 작은 객체 노이즈 제거
erode -> 이미지 객체를 더 줄임
dilate -> 침식으로 줄어든 객체를 다시 확장 시작
dilate -> 객체가 본래의 크기에 가깝게 되돌림

erode -> dilate -> erode -> dilate)
이렇게는 안 된다. 열림 연산은 기본적으로 작은 객체 노이즈 제거하고 큰 객체는 그대로 유지 시켜줘야 해서
내부적으로 openclose를 줄면 실제 침식 침식 팽창 팽창 순으로 하고 있다.

iterations
기본이 1이라서
위 침식 침식 팽창 팽창을 1세트 하는데
iterations = 2로 주면
2세트 한다.

그러니 명시적으로 너가 만들지 말아라. 모폴리지ex를 왠만하면 써라.

https://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html
이거 내용이 06.Bilateral_Filter.jpg 이다.

===========================================================================================================

















